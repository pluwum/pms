# Developed features

1. Read, Create, update and delete a booking
2. Read, Create, update and delete a parking slot
3. Read, Create and delete a user
4. Authentication with api-key passed in header

### Booking Management

-   validation rules
    -   Start date and time of booking cannot be in the past.
    -   Slot being booked cannot have an overlapping booking
    -
-   [Booking entity](src/api/booking/booking.entity.ts)

## Parking slot Management

-   [Parking Slot entity](src/api/parking-slot/parking-slot.entity.ts)

### Authentication

-   is via api-token or x-api-token passed in the headers.
-   Token is autogenerated when user is created or can be provided with user creation payload.
-   verification is performed via middleware.
-   routes with declared as `authenticate: false` are not checked by middleware for api-tokens. Thus is are regarded as open routes.
-

### Authorisation

-   Authorisation is available on two levels
    -   Route level - routes declared `permissions: ["admin", "standard"]` will accept access with tokens associated with an admin role or standard user role.
    -   Operation level - actions like booking have operation level authorisation checks, role information from HTTP request context is used to filter and protect database objects from authorised access or manipulation.

### User Management

-   Is not protected.
-   Was given minimal effort as it was not priority for this task.

### Design Patterns

-   folder structure is inspired by a mixture of clean architecture, layered architecture and vertical slice
-   The project evolved to into this pattern as complexity increased. This arrangement ensures minimal change to several files when adding features, simplifies testing and discoverability and

### Tech stack

-   Typescript - Because it is the language i'm most comfortable with at the moment.
-   Express - for it's light weight nature and ease of setup. It was either express or flask
-   TypeOrm - for it's sqlite in memory database, support for entities, repositories and migrations, this makes
-   Sqlite - For it's light weight nature and ease of setup. I deliberately chose this so I don't have to install specialised database system to start developing the application locally. However, the abstraction provided by the ORM allows us to swap this when the time comes for production deployment.

# What I would given more time.

-   Dockerise the application
-   Swapped database engine for postgres
-   Additional validation for bookings
-   Validation for users
-   Unit tests for the service logic in .service files
-   Integration test covering more edge cases. currently even the validations are not tested.
-   Provide commands to generate seed data.
-   Limit the number of features a standard user is able to make on a given day.
-   Improve typing throughout the codebase. There is high reliance on implicit types, some parts of the code are not typed at all.
